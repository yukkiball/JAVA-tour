1. 基本类型分为boolean和数值类型，两者不能相互转换。（boolean只能为true或者false）

2. 常量池可以缓存字符串直接量

3. 万物皆对象

4. 一个java文件中只能有一个public类，且存在public类时，文件名和类型相同

5. & 和 |作为逻辑符，两边都会执行

6. 函数中参数都是值传递

7. 增强类Arrays（数组常用, import java.util.Arrays）

8. 面向对象三大特性（封装（隐藏）、继承(复用）、多态）

9. package作为第一句，import package的时候，不会把子包中的类import

10. 子类构造器会自动调用父类构造器，当父类构造器有参数时，应用super显式调用，this和super只能出现一个，且在第一行

11. 一个对象拥有编译时类型和运行时类型，对象不能调用编译时类型没有方法，属性不具有多态（多态指的是相同类型的变量调用同一方法时呈现出不同的行为特征）。

12. 使用instanceof 可以判断对象（编译时类型）是否能够强制转换到后者的类型

13. 保证父类良好的封装性，尽量用private， 不希望被子类重写添加final， 尽量不要在父类构造器中调用将要被子类重写的方法

14. 子类重写函数两同两小一大，方法名、形参形同， 返回值、抛出异常类型更小或相等，访问权限比父类访问权限更大或相等

15. 组合是把旧类对象作为新类的成员变量组合进来，通常为private

16. 继承 is a, 组合是has a

17.  创建对象时先调用初始化块（2个），在执行构造器之前执行，声明实例变量也是初始块，子类也会执行父类初始化块

18. String a = new String("abc") 会创建两个对象，首先会使用常量池来管理直接量（直接量只有一个没有副本），然后创建一个String对象

19.  不可变类使用private final修饰成员变量

20. Integer只能缓存-128~127的数值

21. 类的5种成分：代码块、构造器、成员变量、方法、内部类

22. abstract不能修饰变量和构造器

23. static 和abstract 不可以同时修饰方法，但可以修饰内部类

24. abstract 和private 或者final 不可以同时出现

25. 一个接口可以有多个父接口，接口只能继承接口，不能继承类

26. 接口可以包含成员变量（只能是静态变量）， 方法（抽象实例方法、类方法、默认方法或私有方法）、内部类（内部接口、枚举）

27. 接口的常量永远是public static final修饰的，只能在定义时指定默认值。

28.接口里普通方法默认添加public abstract，不能有实现体。内部类默认添加public static

29. 接口默认方法必须用default修饰，不能用static修饰，前面默认加public

30. 加载类时先为静态变量分配空间，创建实例时才为实例变量分配空间

31. 一个类可以实现多个接口，implements必须放在extends前面

32. 非静态内部类不能拥有静态成员（静态方法、静态成员变量、静态初始化块）

33. 外部类变量、内部类变量和局部变量同名时，用外部类名.this.变量和this.变量和变量名区分

34. 接口不能用于创建实例，但是可以用于声明引用类型变量

35. 匿名类： new 实现接口（） | 父类构造器（形参列表）（会立刻创建对象）

36.  别匿名内部类访问的局部变量必须按照有final修饰的方式使用，不能二次赋值

37. Lambda表达式会被当做任意类型的对象，这取决于运行环境的需要

38. Lambda表达式的目标类型是只包含一个抽象方法的接口（函数式接口）

39. Lambda表达式不允许调用接口的默认方法，匿名内部类可以

40. 匿名内部类可以为任意接口或者抽象类普通类创建实例，Lambda只能为函数式接口创建实例

41. 枚举类继承自java.lang.Enum类，不能通过new创建实例，使用valueOf(枚举值）

42. 枚举类的成员变量使用private final来修饰，构造器使用private

43.  枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（系统会自动添加）

44. 可以为每个枚举值提供方法实现

45. 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（数据库连接、网络IO）

46. 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行，当对象永久地失去引用后，系统就会在合适的时候回收它所占的内存

47. 在垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使对象重新复活（让一个引用变量重新引用该对象）， 从而导致垃圾回收机制取消回收

48. 对象在内存中的状态：可达状态（有一个引用变量引用它）、可回复状态（没有引用变量引用，垃圾回收机制准备回收调用finalize方法之前）、不可达状态（调用finalize之后，依然没有变成可达状态，此时会真正回收）

49. 强制垃圾回收System.gc()

50. 输入:import java.util.Scanner, hasNextXxx()和nextXxx()

51 系统相关： System.in/ out/ err / currentTimeMillis() /getProperties() / getEnv()

52 Runtime.getRuntime()获取对象

53 ProcessHandle接口/ ProcessHandle.Info类获取进程相关信息
