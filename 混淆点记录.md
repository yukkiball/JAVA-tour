1. 基本类型分为boolean和数值类型，两者不能相互转换。（boolean只能为true或者false）

2. 常量池可以缓存字符串直接量

3. 万物皆对象

4. 一个java文件中只能有一个public类，且存在public类时，文件名和类型相同

5. & 和 |作为逻辑符，两边都会执行

6. 函数中参数都是值传递

7. 增强类Arrays（数组常用, import java.util.Arrays）

8. 面向对象三大特性（封装（隐藏）、继承(复用）、多态）

9. package作为第一句，import package的时候，不会把子包中的类import

10. 子类构造器会自动调用父类构造器，当父类构造器有参数时，应用super显式调用，this和super只能出现一个，且在第一行

11. 一个对象拥有编译时类型和运行时类型，对象不能调用编译时类型没有方法，属性不具有多态（多态指的是相同类型的变量调用同一方法时呈现出不同的行为特征）。

12. 使用instanceof 可以判断对象（编译时类型）是否能够强制转换到后者的类型

13. 保证父类良好的封装性，尽量用private， 不希望被子类重写添加final， 尽量不要在父类构造器中调用将要被子类重写的方法

14. 子类重写函数两同两小一大，方法名、形参形同， 返回值、抛出异常类型更小或相等，访问权限比父类访问权限更大或相等

15. 组合是把旧类对象作为新类的成员变量组合进来，通常为private

16. 继承 is a, 组合是has a

17.  创建对象时先调用初始化块（2个），在执行构造器之前执行，声明实例变量也是初始块，子类也会执行父类初始化块

18. String a = new String("abc") 会创建两个对象，首先会使用常量池来管理直接量（直接量只有一个没有副本），然后创建一个String对象

19.  不可变类使用private final修饰成员变量

20. Integer只能缓存-128~127的数值

21. 类的5种成分：代码块、构造器、成员变量、方法、内部类

22. abstract不能修饰变量和构造器

23. static 和abstract 不可以同时修饰方法，但可以修饰内部类

24. abstract 和private 或者final 不可以同时出现

25. 一个接口可以有多个父接口，接口只能继承接口，不能继承类

26. 接口可以包含成员变量（只能是静态变量）， 方法（抽象实例方法、类方法、默认方法或私有方法）、内部类（内部接口、枚举）

27. 接口的常量永远是public static final修饰的，只能在定义时指定默认值。

28.接口里普通方法默认添加public abstract，不能有实现体。内部类默认添加public static

29. 接口默认方法必须用default修饰，不能用static修饰，前面默认加public

30. 加载类时先为静态变量分配空间，创建实例时才为实例变量分配空间

31. 一个类可以实现多个接口，implements必须放在extends前面

32. 非静态内部类不能拥有静态成员（静态方法、静态成员变量、静态初始化块）

33. 外部类变量、内部类变量和局部变量同名时，用外部类名.this.变量和this.变量和变量名区分

34. 接口不能用于创建实例，但是可以用于声明引用类型变量

35. 匿名类： new 实现接口（） | 父类构造器（形参列表）（会立刻创建对象）

36.  别匿名内部类访问的局部变量必须按照有final修饰的方式使用，不能二次赋值

37. Lambda表达式会被当做任意类型的对象，这取决于运行环境的需要

38. Lambda表达式的目标类型是只包含一个抽象方法的接口（函数式接口）

39. Lambda表达式不允许调用接口的默认方法，匿名内部类可以

40. 匿名内部类可以为任意接口或者抽象类普通类创建实例，Lambda只能为函数式接口创建实例

41. 枚举类继承自java.lang.Enum类，不能通过new创建实例，使用valueOf(枚举值）

42. 枚举类的成员变量使用private final来修饰，构造器使用private

43.  枚举类里定义抽象方法时不能使用abstract关键字将枚举类定义成抽象类（系统会自动添加）

44. 可以为每个枚举值提供方法实现

45. 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源（数据库连接、网络IO）

46. 程序无法精确控制垃圾回收的运行，垃圾回收会在合适的时候进行，当对象永久地失去引用后，系统就会在合适的时候回收它所占的内存

47. 在垃圾回收机制回收任何对象之前，总会先调用它的finalize()方法，该方法可能使对象重新复活（让一个引用变量重新引用该对象）， 从而导致垃圾回收机制取消回收

48. 对象在内存中的状态：可达状态（有一个引用变量引用它）、可回复状态（没有引用变量引用，垃圾回收机制准备回收调用finalize方法之前）、不可达状态（调用finalize之后，依然没有变成可达状态，此时会真正回收）

49. 强制垃圾回收System.gc()

50. 输入:import java.util.Scanner, hasNextXxx()和nextXxx()

51 系统相关： System.in/ out/ err / currentTimeMillis() /getProperties() / getEnv()

52 Runtime.getRuntime()获取对象

53 ProcessHandle接口/ ProcessHandle.Info类获取进程相关信息

54.  clone只是浅拷贝

55.  System.identityHashCode(Object x)地址的哈希值

56. StringBuffer是线程安全，StringBuilder性能略高（优先使用），append(),insert(),reverse(), delete(), setCharAt(), setLength() 使用toString可以转换为String对象

57.  Objects.toString()更为安全，如果为空指针返回null

58. String类基本操作：charAt, endsWith, equals, indexOf, replace substring, toLowerCase, toUpperCase, valueOf

59. 使用BigDecimal, 应用BigDecimal.valueOf()创建浮点数，防止精度丢失 add，divide, muiltpy, divide, pow, doubleValue(返回double)

60.  HashSet中如果两个对象的equals方法返回true，那么两个对象的hashcode也应该相同

61.  HashSet中添加可变对象时，不要修改集合元素中参与计算hashCode和equals的实例变量

62.  LinkedHashSet中元素的保存顺序和插入顺序相同

63. TreeSet中元素处于排序状态（红黑树数据结构，添加对象时必须实现Comparable接口）

64.  集合类只能保存对象（由两个接口派生Collection和Map）

65.  当两个对象通过equals方法返回true时， compareTo方法应该返回0

66. ArrayList和ArrayDeque内部是数组储存，LinkedList内部是链表

67. 尽量使用ArrayDeque代替Stack

68. Arrays.asList返回的是Arrays内部的ArrayList（和普通的不同），不能添加删除元素

69. HashMap, LinkedHashMap（插入顺序排序）, TreeMap（value大小排序）

70. 当产生hash冲突时，同一个桶中会使用链表储存，负载极限默认为0.75

71. Collections工具类对Set、List、Map进行操作，reverse, shuffle, sort, swap, rotate, min, max, fill, binarySearch, frequency

72. Collections.synchronizedXxx()可以包装成线程同步集合

73. 使用List/Set/Map.of方法可以创建不可变集合

74. 包含泛型声明的类型可以在定义变量、创建对象时传入一个类型实参，从而可以动态地生成无数多个逻辑上的子类，但这种子类在物理上并不存在

75. 可以为任何类、接口增加泛型声明，当使用这些接口时，父类不能再包含形参

76. 不管为泛型传入哪一种类型的实参，都被当成同一个类来处理，在内存中只占用一块内存空间， 在静态方法，静态初始快或者静态变量的声明和初始化中不允许使用泛型形参

77. List<String>并不是List<Object>的子类
 
78. Java数组支持类型转变，集合不支持类型转变

79. List<? extends Shape>通配符设定上限

80. 协变， Foo是Bar的子类，A<Bar>相当于A<? extends Foo>的子类，可以将A<Bar>赋值给A<? extends Foo>（作为形参），协变只出不进

81. 对于通配符？，其上限为Object

82. 逆变， A<? super Foo>, 可以向其中添加元素，取出的元素都被当成Object类型处理

83. 定义泛型形参时也可以设定上限，public class A <T extends Number>
  
84. 若泛型形参T产生的唯一效果是可以在不同的调用点传入不同的实际类型，应该使用类型通配符， 泛型方法用来表示方法 的一个或多个参数之间的类型依赖关系
